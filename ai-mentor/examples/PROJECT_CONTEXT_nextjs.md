# Project Context — Next.js Example

> Generated by @onboarding. This is an example for a Next.js App Router project.

---

## Tech Stack

TypeScript · Next.js 15 App Router · React 19 · Prisma 6 · PostgreSQL · NextAuth 5 · Tailwind CSS 4 · Zod · Vitest

## Architecture Pattern

```
Component → Server Action → Service → Prisma
```

- **Components**: UI only. No business logic. No direct database calls.
- **Server Actions**: Auth check → Zod validation → call service → revalidate path → return result.
- **Services**: Business logic lives here. All database queries. Event emission after mutations.
- **Prisma**: Data access only. No business logic in raw queries.

## Key Files

| File | Purpose |
|------|---------|
| `app/layout.tsx` | Root layout with providers |
| `app/s/layout.tsx` | Authenticated layout (session gating) |
| `lib/actions/` | Server actions directory |
| `lib/services/` | Service layer directory |
| `lib/schema/` | Zod validation schemas |
| `prisma/schema.prisma` | Database schema |
| `auth.ts` | NextAuth configuration |
| `tests/helpers/factories.ts` | Test data factories |
| `tests/helpers/prisma-mock.ts` | Prisma mock setup for unit tests |

## Code Style

- **Naming**: camelCase for functions/variables, PascalCase for components/types
- **UI text**: German (all user-facing strings)
- **Imports**: Absolute paths with `@/` prefix
- **Server actions**: Must start with `"use server"` directive
- **Formatting**: Prettier via eslint config

### Server Action Skeleton

```typescript
"use server";
import { auth } from "@/auth";
import { revalidatePath } from "next/cache";

export async function xAction(params) {
  const session = await auth();
  if (!session?.user) throw new Error("Unauthorized");
  const validated = XSchema.safeParse(params);
  if (!validated.success) return { success: false, error: validated.error.flatten() };
  const result = await xService(validated.data);
  revalidatePath("/s/...");
  return { success: true, data: result };
}
```

### Service Skeleton

```typescript
export async function xService(params: ValidatedParams) {
  const result = await prisma.x.update({ where: { ..., deletedAt: null }, data: { ... } });
  await emitEvent(result.id, "EVENT_TYPE", { ... });
  return result;
}
```

## Doc Map

| Doc | Answers the question | Key contents |
|-----|---------------------|--------------|
| `docs/AGENT.md` | "What are the architecture rules?" | Service layer flow, server action pattern, schema reference, iteration status |
| `docs/ARCHITECTURE_DECISIONS.md` | "Why was X decided this way?" | Chronological AD log, rejected alternatives |
| `docs/ROADMAP.md` | "What's done and what's next?" | Iteration checklists, completion status |
| `docs/DEVELOPER.md` | "How do I run this?" | Dev setup, commands, environment variables |
| `TODO.md` | "What's broken or pending?" | Open issues categorized by severity |

## Boundaries

### Always Do (Project-Specific)

- Verify `auth()` session in every server action
- Validate input with Zod in every mutation
- Filter `deletedAt IS NULL` in every query (soft delete pattern)
- Follow `Component → Server Action → Service → Prisma` flow
- Use German for all UI-facing strings

### Never (Project-Specific)

- Business logic in components or API routes
- Skip auth checks in server actions
- DB-level cascade deletes (use app-level BFS cascade)
- Import from `lib/toggl/` outside the Toggl feature boundary
- Secrets or API tokens in `.env` / `process.env` without the config layer

## Goals

- Focus areas: Architecture & Patterns, Testing Strategy
- "Good code" here means: follows the established layer pattern, handles edge cases, is testable at the service layer, and includes rationale for non-obvious decisions.
