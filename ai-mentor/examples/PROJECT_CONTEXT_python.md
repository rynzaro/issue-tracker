# Project Context — Python/Django Example

> Generated by @onboarding. This is an example for a Django REST Framework project.

---

## Tech Stack

Python 3.12 · Django 5.1 · Django REST Framework · PostgreSQL · Celery · Redis · pytest · ruff

## Architecture Pattern

```
Serializer → ViewSet → Service → Model/QuerySet
```

- **Serializers**: Input validation and output formatting. No business logic.
- **ViewSets**: HTTP interface. Permission checks → call service → return serialized response.
- **Services**: Business logic lives here (in `services/` modules). All complex queries and mutations.
- **Models**: Data definition and simple queries (custom managers/querysets for reusable filters).
- **Tasks**: Async work via Celery. Called from services, never from views directly.

## Key Files

| File | Purpose |
|------|---------|
| `config/settings/` | Django settings (base, local, production) |
| `apps/core/services/` | Core business logic |
| `apps/core/api/views.py` | API ViewSets |
| `apps/core/api/serializers.py` | DRF serializers |
| `apps/core/models.py` | Django models |
| `apps/core/tasks.py` | Celery tasks |
| `apps/core/tests/factories.py` | Factory Boy test factories |
| `conftest.py` | Shared pytest fixtures |

## Code Style

- **Naming**: snake_case for everything except classes (PascalCase)
- **UI text**: English (i18n via Django's `gettext`)
- **Imports**: isort ordering (stdlib → third-party → local), absolute imports
- **Type hints**: Required on all function signatures (enforced by mypy)
- **Formatting**: ruff format (88 char line length)

### Service Pattern

```python
# apps/core/services/order_service.py
from apps.core.models import Order
from apps.core.tasks import send_order_notification

def create_order(*, user, items, shipping_address):
    """Create an order with validation and side effects."""
    if not items:
        raise ValidationError("Order must have at least one item")
    
    order = Order.objects.create(
        user=user,
        shipping_address=shipping_address,
        status=Order.Status.PENDING,
    )
    order.items.set(items)
    send_order_notification.delay(order.id)
    return order
```

### ViewSet Pattern

```python
class OrderViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    
    def perform_create(self, serializer):
        order = create_order(
            user=self.request.user,
            **serializer.validated_data,
        )
        serializer.instance = order
```

## Doc Map

| Doc | Answers the question | Key contents |
|-----|---------------------|--------------|
| `docs/architecture.md` | "How is the code organized?" | App structure, service pattern, async patterns |
| `docs/api.md` | "What endpoints exist?" | Auto-generated from DRF schema |
| `CHANGELOG.md` | "What changed recently?" | Versioned change log |
| `Makefile` | "How do I run things?" | Common commands (test, migrate, lint) |

## Boundaries

### Always Do (Project-Specific)

- Use services for all business logic (never in views or serializers)
- Check permissions in ViewSets (use DRF permission classes)
- Use `select_related`/`prefetch_related` for all querysets with relations
- Write type hints on all function signatures
- Use Factory Boy for test data (never create models directly in tests)

### Never (Project-Specific)

- Business logic in views, serializers, or templates
- Raw SQL without code review approval
- Synchronous external API calls (use Celery tasks)
- Import between apps except through their public service interface
- Mutate querysets in serializers

## Goals

- Focus areas: Testing Strategy, System Thinking
- "Good code" here means: thin views, fat services, fully typed, tested at the service layer, and async-safe.
