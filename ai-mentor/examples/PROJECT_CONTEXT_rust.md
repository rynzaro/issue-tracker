# Project Context — Rust Example

> Generated by @onboarding. This is an example for a Rust Axum web service.

---

## Tech Stack

Rust 1.82 · Axum 0.8 · SQLx · PostgreSQL · Tokio · Serde · Tower · cargo-nextest

## Architecture Pattern

```
Handler → Service → Repository → SQLx Query
```

- **Handlers**: HTTP interface. Extract request data → call service → build response. No business logic.
- **Services**: Business logic and orchestration. Accept validated DTOs, return domain types.
- **Repositories**: Database access. Accept/return domain types. All SQL lives here.
- **Domain types**: `struct`s in `domain/` — the vocabulary of the system. Not tied to HTTP or DB.

## Key Files

| File | Purpose |
|------|---------|
| `src/main.rs` | Server startup, router, state initialization |
| `src/routes/mod.rs` | Route definitions |
| `src/handlers/` | HTTP handlers |
| `src/services/` | Business logic |
| `src/repositories/` | Database access layer |
| `src/domain/` | Domain types and errors |
| `src/extractors/` | Custom Axum extractors (auth, pagination) |
| `migrations/` | SQLx migrations |
| `tests/` | Integration tests |
| `Cargo.toml` | Dependencies and workspace config |

## Code Style

- **Naming**: snake_case (Rust convention), PascalCase for types/traits
- **Error handling**: Custom `AppError` enum implementing `IntoResponse`. Use `?` operator, never `unwrap()` in production code.
- **Async**: All handlers and services are async. Use `tokio::spawn` for background work.
- **Formatting**: `rustfmt` defaults (cargo fmt)
- **Linting**: `clippy` with `pedantic` lint group enabled

### Handler Pattern

```rust
pub async fn create_order(
    State(state): State<AppState>,
    AuthUser(user): AuthUser,
    Json(payload): Json<CreateOrderRequest>,
) -> Result<Json<OrderResponse>, AppError> {
    let order = state.order_service
        .create_order(user.id, payload.into())
        .await?;
    Ok(Json(order.into()))
}
```

### Service Pattern

```rust
impl OrderService {
    pub async fn create_order(
        &self,
        user_id: Uuid,
        input: CreateOrderInput,
    ) -> Result<Order, AppError> {
        if input.items.is_empty() {
            return Err(AppError::Validation("Order must have items".into()));
        }
        let order = self.repo.insert_order(user_id, &input).await?;
        self.event_bus.emit(OrderCreated { order_id: order.id }).await;
        Ok(order)
    }
}
```

## Doc Map

| Doc | Answers the question | Key contents |
|-----|---------------------|--------------|
| `docs/architecture.md` | "How is the code organized?" | Layer diagram, error handling strategy, auth flow |
| `docs/api.md` | "What endpoints exist?" | Endpoint list with request/response types |
| `CHANGELOG.md` | "What changed recently?" | Keep-a-changelog format |
| `README.md` | "How do I run this?" | Setup, environment variables, cargo commands |

## Boundaries

### Always Do (Project-Specific)

- Extract auth via `AuthUser` extractor in every protected handler
- Use `AppError` for all error returns (never `String` or `anyhow` in handler signatures)
- Use `sqlx::query_as!` macro for type-checked queries
- Run `cargo clippy --all-targets` before committing
- Domain types in `domain/` must not depend on HTTP or database types

### Never (Project-Specific)

- `unwrap()` or `expect()` in production code (only in tests)
- Business logic in handlers (handlers are thin wrappers)
- Direct SQL in services (use repository layer)
- `Clone` on large structs without justification (use references or `Arc`)
- Blocking calls (use `tokio::task::spawn_blocking` if unavoidable)

## Goals

- Focus areas: Error Handling, Architecture & Patterns
- "Good code" here means: the type system catches bugs at compile time, errors are meaningful (not just "500 Internal Server Error"), and ownership/borrowing is idiomatic.
